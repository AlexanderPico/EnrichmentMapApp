/**
 **                       EnrichmentMap Cytoscape Plugin
 **
 ** Copyright (c) 2008-2009 Bader Lab, Donnelly Centre for Cellular and Biomolecular 
 ** Research, University of Toronto
 **
 ** Contact: http://www.baderlab.org
 **
 ** Code written by: Ruth Isserlin
 ** Authors: Daniele Merico, Ruth Isserlin, Oliver Stueker, Gary D. Bader
 **
 ** This library is free software; you can redistribute it and/or modify it
 ** under the terms of the GNU Lesser General Public License as published
 ** by the Free Software Foundation; either version 2.1 of the License, or
 ** (at your option) any later version.
 **
 ** This library is distributed in the hope that it will be useful, but
 ** WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
 ** MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
 ** documentation provided hereunder is on an "as is" basis, and
 ** University of Toronto
 ** has no obligations to provide maintenance, support, updates, 
 ** enhancements or modifications.  In no event shall the
 ** University of Toronto
 ** be liable to any party for direct, indirect, special,
 ** incidental or consequential damages, including lost profits, arising
 ** out of the use of this software and its documentation, even if
 ** University of Toronto
 ** has been advised of the possibility of such damage.  
 ** See the GNU Lesser General Public License for more details.
 **
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with this library; if not, write to the Free Software Foundation,
 ** Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 **
 **/

// $Id$
// $LastChangedDate$
// $LasrChangedRevision$
// $LastChangedBy$
// $HeadURL$

package org.baderlab.csplugins.enrichmentmap;

import cytoscape.task.Task;
import cytoscape.task.TaskMonitor;
import cytoscape.data.readers.TextFileReader;

import javax.swing.*;
import java.io.File;
import java.util.HashMap;
import java.util.Arrays;
import java.util.Iterator;

/**
 * Created by
 * User: risserlin
 * Date: May 1, 2009
 * Time: 9:10:22 AM
 */
public class RanksFileReaderTask implements Task {

    private EnrichmentMapParameters params;
    private String RankFileName;
    private int dataset;

    // Keep track of progress for monitoring:
    private int maxValue;
    private TaskMonitor taskMonitor = null;
    private boolean interrupted = false;

    public RanksFileReaderTask(EnrichmentMapParameters params, String rankFileName, int dataset) {
        this.params = params;
        RankFileName = rankFileName;
        this.dataset = dataset;
    }

    public RanksFileReaderTask(EnrichmentMapParameters params, String rankFileName, int dataset, TaskMonitor taskMonitor) {
        this.params = params;
        RankFileName = rankFileName;
        this.dataset = dataset;
        this.taskMonitor = taskMonitor;
    }

    public void parse(){

        TextFileReader reader = new TextFileReader(RankFileName);
        reader.read();
        String fullText = reader.getText();

        String[] lines = fullText.split("\n");
        int currentProgress = 0;
        maxValue = lines.length;

        HashMap genes = params.getGenes();
        Double[] sort_scores = new Double[lines.length-1];

        HashMap<Integer,Ranking> ranks = new HashMap<Integer,Ranking>();

        /* there are two possible Rank files
    If loaded through the rpt file the file is the one generated by
    GSEA and will have 5 columns (name, description, empty,empty,score)
    If the user loaded it through the generic of specifying advanced options
    then it will 2 columns (name,score).
    The score in either case should be a double and the name a string so
    check for either option. */

        for (int i = 1; i < lines.length; i++) {
            Integer genekey ;

            String line = lines[i];

            String [] tokens = line.split("\t");

            String name = tokens[0];
            double score = 0;

            if(tokens.length == 5 ){
                score = Double.parseDouble(tokens[4]);
            }
            else if(tokens.length == 2){
                score = Double.parseDouble(tokens[1]);
            }
            else{
                System.out.println("Invalid number of tokens line of Rank File (should be 5 or 2)");
            }

            //add score to array of scores
            sort_scores[i-1] = score;

            //check to see if the gene is in the genelist
            if(genes.containsKey(name)){
                genekey = (Integer)genes.get(name);
                Ranking current_ranking = new Ranking(name,score);
                ranks.put(genekey, current_ranking);
            }

            // Calculate Percentage.  This must be a value between 0..100.
            int percentComplete = (int) (((double) currentProgress / maxValue) * 100);
            //  Estimate Time Remaining
            long timeRemaining = maxValue - currentProgress;
            if (taskMonitor != null) {
                    taskMonitor.setPercentCompleted(percentComplete);
                    taskMonitor.setStatus("Parsing Rank file " + currentProgress + " of " + maxValue);
                    taskMonitor.setEstimatedTimeRemaining(timeRemaining);
                }
            currentProgress++;

        }

        //after we have loaded in all the scores, sort the score to compute ranks
        //create hash of scores to ranks.
        HashMap<Double,Integer> score2ranks = new HashMap<Double,Integer> ();
        Arrays.sort(sort_scores);

        for(int j = 0; j<sort_scores.length;j++){
            //check to see if this score is already enter
            if(!score2ranks.containsKey(sort_scores[j]))
                    score2ranks.put(sort_scores[j],j-1);
        }

        //update scores Hash to contain the ranks as well.
        for(Iterator k = ranks.keySet().iterator(); k.hasNext();){
            Ranking current_ranking = ranks.get(k.next());
            current_ranking.setRank(score2ranks.get(current_ranking.getScore()));
        }

        if(dataset == 1){
            params.setDataset1Rankings(ranks);
        }
        else{
            params.setDataset2Rankings(ranks);
        }

    }

    /**
     * Run the Task.
     */
    public void run() {
        parse();
    }

    /**
     * Non-blocking call to interrupt the task.
     */
    public void halt() {
        this.interrupted = true;
    }

     /**
     * Sets the Task Monitor.
     *
     * @param taskMonitor TaskMonitor Object.
     */
    public void setTaskMonitor(TaskMonitor taskMonitor) {
        if (this.taskMonitor != null) {
            throw new IllegalStateException("Task Monitor is already set.");
        }
        this.taskMonitor = taskMonitor;
    }

    /**
     * Gets the Task Title.
     *
     * @return human readable task title.
     */
    public String getTitle() {
        return new String("Parsing Ranks file");
    }
}
